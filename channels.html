<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>channels</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="css/main.css" />
  <link rel="stylesheet" type="text/css" href="css/normalize.css" />
  <link rel="stylesheet" type="text/css" href="css/ghp.css" />
</head>
<body>
<div class="content">
<h1 class="libTop">Channels</h1>

<p>2012-09-16, edited -09-21</p>
<p>Channel communications may be nested.  The lowest level channel represents
a point-to-point link between nodes.  Keep-alives are run at this level.
It might be useful to look at hardware P2P link protocols.  Call this
lowest level a p2p channel.</p>
<p>Tentatively a p2p channel consists of two paired links.  The owner
of a channel can send on one link and receive on the other.  There is a
buffer associated with each link.  These are send and receive buffers.</p>
<p>There must be a buffer associated with each direction, but such
a buffer can be replaced.  Buffers can be initialized (cleared)
at any time.  A buffer has an offset, limit, and capacity.  Initializing
a buffer resets the offset to zero and the limit to the buffer's
capacity.  The limit may be set to any value between the offset and the
capacity, inclusive.</p>
<p>P2P channels are paired.  One channel acts as the client, or initiator.
The other acts as the server, or reactive component.</p>
<p>From either side the offset, limit, and capacity of the channel can
be read.  The channel can also be initialized.  Writing to the
buffer increases the offset accordingly, but not beyond the limit.
The limit can be set at any time.</p>
<h2>Opening a Channel</h2>
<p>From the clients's point of view the channel is either open or closed.
Opening the channel sets a timeout to a non-negative number of seconds.
By default the timeout is zero, interpreted as meaning infinity.  If
the timeout occurs, the channel is closed.</p>
<p>When the client opens the channel, an initial keep-alive message is sent
to the server.  This specifies the timeout on the channel.</p>
<p>After opening the channel, the channel can send either a switch protocol
message or any number of keepalives.</p>
<h2>Protocol Negotiation</h2>
<p>The switch protocol message is an fbytes20, interpreteted by the server
as the content hash of a protocol.   The server can reply with an OK, after
which data packets are treated as messages in that protocol, or it can
reply with a</p>
<pre><code>GetProto fbytes20           # the hash
</code></pre>
<p>to which the client should reply</p>
<pre><code>PUT fbytes20 lbytes         # the content hash, length, that many bytes
</code></pre>
<p>If this is consistent (the length corresponds to the number of bytes sent
and the the payload hashes to the expected value) the server replies OK
and protocol-based traffic starts.</p>
<p>If the PUT message is inconsistent, the server will reply with an</p>
<pre><code>ErrorMsg vuint32 lstring    # code, text
</code></pre>
<p>and close the connection.</p>
<h2>Protocol-based Communications</h2>
<p>At this level, further communications at this level consist of</p>
<pre><code>client                      server

KeepAlive                   Ack
DataMsg lbytes              DataReply lbytes
SwitchProto fbytes20        OK | GetProto fbytes20
PutProto fbytes20 lbytes    OK | ErrMsag vuint32 lstring
ErrMsg vuint32 lstring      .
</code></pre>
<p>This is the core protocol plus the DataMsg and DataReply messages
with their opaque content.</p>
<p>If the client sends SwitchProto NoProto, where NoProto is an fbytes20
consisting of 20 zero bytes, there is no active prototocol, and a
DataMsg or DataReply will cause an ErrMsg to be sent by the opposite
and the channel to be closed.</p>
<p>None of this traffic is visible to clients, except that the buffer
holding the DataMsg will have been written by the client and the
buffer holding the DataReply will be switched into the client's
view.</p>
<h2>Higher Level Channels</h2>
<p>The client initiates communications by associating a channel with
its application.  This channel uses the lower level channel for
communications.</p>
<p>The client application opens the higher level channel with a</p>
<pre><code>chan = DataChannel.open(endPoint, protocolName)
</code></pre>
<p>command.  This finds the CoreChannel associated with the endpoint
and causes it to be associated with the protocol.  That is, the
client CoreChannel sends a SwitchProto message to the far end; if
this succeeds, the DataChannel is opened, bound to the new protocol.
The client application can then send and receive messages using the
designated protocol.</p>
<p>Higher level protocols will generally import OK, Ack, and ErrMsg from
the core protocol.</p>
<h2>Routing</h2>
<p>Routing protocols are very similar to the core protocol in that they
have few message types and that these include GET and PUT operations
on opaque data.</p>  <div class="f">
    <hr />
    <div class="license">
      <p><a href="LICENSE-APACHE-2.0.html">SOFTWARE LICENSE</a></p>
    </div>
    <div class="project">
      github <a href="https://github.com/jddixon/channels">      <img src="img/GitHub-Mark-32px.png" 
        alt="link to project"  
        style="display: inline-block; margin-left: 0 auto; margin-right: 0 auto">
       </a> project
    </div>
    <div class="logo" >
      <a href="https://jddixon.github.io/xlattice/">
      <img src="img/xlattice-2014.jpg" alt="the XLattice Project" style="float: right;" >
      </a>
    </div>
  </div>
</div>
</body>
</html>
